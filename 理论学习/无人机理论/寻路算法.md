
在 **已知地图** 上进行寻路的算法，因为要求知道地图中障碍物的位置，是非端到端的模型常使用的，要求先感知-建图，然后才能进行规划-控制。

---
### A* 算法
#### 广度优先搜索 BFS
回到图相关的理论中，在一个无权图（或者权值均相同）中，通过BFS可以找到一条从起点到终点的最短路径
#### Dijkstra 算法
当面对的是带权图时，dijkstra算法（1956年）每次寻找到已遍历集合距离最小的点加入到集合中（其实就是每一步选择到起点最近的点）。当图形为网格图且每个网格间移动距离一致时，dijkstra和bfs一致。
#### Best First 算法
通常来说，在开始时是无法计算起点到终点的代价的，例如dijkstra每一步选择到“已遍历集”代价最小的点，其实就是每一步在计算到起点最近的点。
但是如果可以预先知道每个节点到终点的距离，则可以每一步选择到终点最近的点（在当前可达的点中），这样可以加快路径的搜索速度。但是当起点和终点间存在障碍物时，该算法可能并不是最短路径。
#### A* 算法
既然dijkstra能找到最短路径但是搜索较慢，best first搜索较快但不一定是最短路径，那么有没有折中的方法？ A* 便是结合两种算法的特点，在1968年提出，可以视为dijkstra的扩展。A* 通过以下函数来计算每个节点的代价f(n)：
f(n) = g(n) + h(n)

其中g(n)代表节点n到起点的代价，h(n)是节点n到终点的预期代价，也称为A* 的启发函数。每一步中，A* 采取f(n)最小的节点。此外，已遍历节点和待遍历节点分别采用`close_set`和`open_set`表示
``` text
* 初始化open_set和close_set；
* 将起点加入open_set中，并设置优先级为0（优先级最高）；
* 如果open_set不为空，则从open_set中选取优先级最高的节点n：
    * 如果节点n为终点，则：
        * 从终点开始逐步追踪parent节点，一直达到起点；
        * 返回找到的结果路径，算法结束；
    * 如果节点n不是终点，则：
        * 将节点n从open_set中删除，并加入close_set中；
        * 遍历节点n所有的邻近节点：
            * 如果邻近节点m在close_set中，则：
                * 跳过，选取下一个邻近节点
            * 如果邻近节点m也不在open_set中，则：
                * 设置节点m的parent为节点n
                * 计算节点m的优先级
                * 将节点m加入open_set中
```
**启发函数**
启发函数的选择并不固定，不同选择会影响A* 的行为。
- 在极端情况下，当启发函数h(n)始终为0，则将由g(n)决定节点的优先级，此时算法就退化成了Dijkstra算法。
- 如果h(n)始终小于等于节点n到终点的代价，则A* 算法保证一定能够找到最短路径。但是当h(n)的值越小，算法将遍历越多的节点，也就导致算法越慢。
- 如果h(n)完全等于节点n到终点的代价，则A* 算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。
- 如果h(n)的值比节点n到终点的代价要大，则A* 算法不能保证找到最短路径，不过此时会很快。
- 在另外一个极端情况下，如果h(n)相较于g(n)大很多，则此时只有h(n)产生效果，这也就变成了最佳优先搜索。

在网格地图中通常可以选择 曼哈顿距离（只允许上下左右移动），对角距离（允许斜向移动），欧氏距离（允许任意方向移动）

---
### Hybrid A* 算法
A* 算法虽然结合了搜索快速和最短路径的优点，但是在实际使用中仍然存在问题。首先是**离散性**：A* 假设只能从一个网格的中心移动到另一个网格的中心；其次是**忽略动力学约束**：A* 产生的路径是由折线段组成的，但是实际对于汽车或无人机折线路径是完全不可行的。

于是在2007年，斯坦福提出了 混合了车辆动力学 的混合A* 。
![[混合A star对比图.png]]