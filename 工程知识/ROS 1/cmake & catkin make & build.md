
简单来说，三者都是cpp的编译工具。
首先，因为ros项目非常依赖本地环境且要进行自主修改，所以基本都需要在本地对源码进行编译。（拓展：对于一个cpp的应用程序，其是否需要上述内容？并不需要，一个应用程序可以以编译后的二进制形式发布。一种方式是静态连接，将依赖抄进exe文件；第二种方式是动态链接，例如使用win的dll，在运行时编译，这样只需要一个安装程序，在安装时将这些文件放到指定文件夹中）

# cmake
对于简单的cpp文件编译，例如只有两个文件，可以用命令行手动编译
```bash
g++ main.cpp lib.cpp -o final
```
但是实际中，ros项目的可能有几十上百个需编译的文件，分布在不同文件夹中，且有极多路径不同的依赖和头文件。每次手动敲指令编译太过困难。

因而有了`makefile`文本文件，将编译指令输进去，之后每次输入make即可执行编译过程。
但是`makefile`也有问题。例如不同平台的文件路径不同，相同的依赖可能在不同的路径中，且每次新加一个文件就需要手动修改`makefile`

于是有了cmake工具，根据电脑环境自动生成`makefile`。相当于多了一个中间层，使用者通过更高层的`CMakeList.txt`去自动生成更底层的makefile。cmake有几大特点：首先会自动寻找依赖，第二可以跨平台使用，第三其通过让顶层cmakelist指挥底层cmakelist可以管理超大项目。

# catkin make
可以视为cmake的高阶封装版，ROS1自带的编译工具，用于高效地构建众多相互依赖但独立开发的CMake项目。有一个workspace，将ws下视为一个巨大的cmake项目。

缺点在于没有实现包的隔离，会导致变量名冲突，以及修改一个包需要重新检查整个工作空间的依赖关系


# catkin build
由`catkin_tools`提供的更现代ROS1的编译工具，需要自己下载。可以实现多个包并行的单独编译，提供单独的build文件夹和日志等，有更好的输出结果展示。

# 扩展
catkin工具都是ROS1专用的，即仅能用于ROS项目（其他工具无法识别package.xml文件），且只适用于1代。

ROS2则使用`colcon`，在继承了catkin build的并行隔离编译的基础上，还支持多种语言的项目

而其他大型cpp项目，一般可以用`Ninja+CMake`进行编译